// -*- tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
// vi: set et ts=4 sw=2 sts=2:
#ifndef DUNE_QUADRATURERULES_HH
#define DUNE_QUADRATURERULES_HH

#include <iostream>
#include <vector>

#include <dune/common/fvector.hh>
#include <dune/common/exceptions.hh>
#include <dune/common/stdstreams.hh>
#include <dune/common/geometrytype.hh>

namespace Dune {

  /**
     Exception thrown if an Aquired Exception is not available,
     because the order is to high
   */
  class QuadratureOrderOutOfRange : public NotImplemented {};

  /***********************************************************
  * Interface for quadrature points and rules
  ***********************************************************/

  //! quadrature rules for cubes of any dimension based on Gauss quadrature
  template<typename ct, int dim>
  class QuadraturePoint {
  public:
    // compile time parameters
    enum { d=dim };
    typedef ct CoordType;

    //! set up quadrature of given order in d dimensions
    QuadraturePoint (const FieldVector<ct, dim>& x, double w) : local(x)
    {
      wght = w;
    }

    //! return local coordinates of integration point i
    const FieldVector<ct, dim>& position () const
    {
      return local;
    }

    //! return weight associated with integration point i
    double weight () const
    {
      return wght;
    }
    virtual ~QuadraturePoint(){}

  protected:
    FieldVector<ct, dim> local;
    double wght;
  };

  /**
   * Defines an \p enum for currently available quadrature rules.
   */
  namespace QuadratureType {
    enum {
      Gauss      = 0,

      Jacobian_1_0 = 1,
      Jacobian_2_0 = 2,

      Simpson    = 3,
      Trap       = 4,
      Grid       = 5,

      Clough     = 21,

      Invalid_Rule = 127
    };
  };

  //! abstract base class for quadrature rules
  template<typename ct, int dim, int QType=QuadratureType::Gauss>
  class QuadratureRule : public std::vector<QuadraturePoint<ct,dim> >
  {
  public:
    QuadratureRule(){}
    // compile time parameters
    enum { d=dim };
    typedef ct CoordType;

    //! return order
    virtual int order () const = 0;

    //! return type of element
    virtual GeometryType type () const = 0;
    virtual ~QuadratureRule(){}

  protected:
    void tensor_product (QuadratureRule<ct,1,QType> & q1d)
    {
      // fill in all the gauss points
      int m = q1d.size();
      int n = power(m,dim);
      for (int i=0; i<n; i++)
      {
        // compute multi index for Gauss point
        int x[dim];
        int z = i;
        for (int k=0; k<dim; ++k)
        {
          x[k] = z%m;
          z = z/m;
        }

        // compute coordinates and weight
        double weight = 1.0;
        FieldVector<ct, dim> local;
        for (int k=0; k<dim; k++)
        {
          local[k] = q1d[x[k]].position()[0];
          weight *= q1d[x[k]].weight();
        }

        // put in container
        push_back(QuadraturePoint<ct,dim>(local,weight));
      }
    }

    int power (int y, int d)
    {
      int m=1;
      for (int i=0; i<d; i++) m *= y;
      return m;
    }
  };

  /***********************************************************
  * Gauss quadrature for the n-dimensional cube
  ***********************************************************/

  //! A cube quadrature rule for a fixed order is a container of cube quadrature points
  template<typename ct, int dim, int QType=QuadratureType::Gauss>
  class CubeQuadratureRule : public QuadratureRule<ct,dim,QType>
  {};

  template<typename ct>
  class CubeQuadratureRule<ct,1,QuadratureType::Gauss> :
    public QuadratureRule<ct,1,QuadratureType::Gauss>
  {
  public:
    // compile time parameters
    enum { d=1 };
    enum { dim=1 };
    enum { highest_order=43 };
    typedef ct CoordType;
    typedef CubeQuadratureRule value_type;

    CubeQuadratureRule (int p);

    //! return order
    int order () const
    {
      return delivered_order;
    }

    //! return type of element
    GeometryType type () const
    {
      static const GeometryType cube (GeometryType::cube, d);
      return cube;
    }

    //! appear as your own container
    const CubeQuadratureRule& getelement (GeometryType type, int p)
    {
      return *this;
    }

    ~CubeQuadratureRule(){}
  private:
    int delivered_order;  // delivered order
  };

  template<typename ct, int dim>
  class CubeQuadratureRule<ct,dim,QuadratureType::Gauss> :
    public QuadratureRule<ct,dim,QuadratureType::Gauss>
  {
  public:
    // compile time parameters
    enum { d=dim };
    enum { highest_order=CubeQuadratureRule<ct,1,QuadratureType::Gauss>::highest_order };
    enum { QType=QuadratureType::Gauss };
    typedef ct CoordType;
    typedef CubeQuadratureRule value_type;

    //! set up quadrature of given order in d dimensions
    CubeQuadratureRule (int p)
    {
      CubeQuadratureRule<ct,1,QType> q1D(p);
      tensor_product( q1D );
      delivered_order = q1D.order();
    }

    //! return order
    int order () const
    {
      return delivered_order;
    }

    //! return type of element
    GeometryType type () const
    {
      static const GeometryType cube (GeometryType::cube, d);
      return cube;
    }

    //! appear as your own container
    const CubeQuadratureRule& getelement (GeometryType type, int p)
    {
      return *this;
    }
    ~CubeQuadratureRule(){}
  private:
    int delivered_order;      // delivered order
  };

  /*********************************
   * Quadrature rules for Simplices
   ***********************************/

  //--specialization for simplex DIM==1
  //--it use cube quadrature rule for DIM==1
  template<typename ct, int dim>
  class SimplexQuadratureRule;

  template<typename ct>
  class SimplexQuadratureRule<ct,1> : public CubeQuadratureRule<ct,1>
  {
  public:
    enum {d=1};
    enum {dim=1};
    enum {highest_order=CubeQuadratureRule<ct,1>::highest_order};
    typedef ct CoordType;
    typedef SimplexQuadratureRule value_type;
    SimplexQuadratureRule(int p) :
      CubeQuadratureRule<ct,1>(p) {}

    //! return type of element
    GeometryType type () const
    {
      static const GeometryType simplex (GeometryType::simplex, d);
      return simplex;
    }

    //! appear as your own container
    const SimplexQuadratureRule<ct,dim>& getelement (GeometryType type, int p)
    {
      return *this;
    }
    ~SimplexQuadratureRule(){}
  };


  /************************************************
   * Quadrature points for Simplices/ triangle
   *************************************************/

  //!
  template<int dim>
  class SimplexQuadraturePoints;

  template<>
  class SimplexQuadraturePoints<2>

  {
  public:
    enum { MAXP=33};
    enum { highest_order=12 };

    //! initialize quadrature points on the interval for all orders
    SimplexQuadraturePoints ()
    {
      int m = 0;
      O[m] = 0;

      // polynom degree 1
      m = 1;
      G[m][0][0] = 0.3333333333;
      G[m][0][1] = 0.3333333333;
      W[m][0] = 0.5;
      O[m] = 1;

      // polynom degree 2
      // symmetric
      m = 3;
      G[m][0][0] = 4.0/6.0;
      G[m][0][1] = 1.0/6.0;
      G[m][1][0] = 1.0/6.0;
      G[m][1][1] = 4.0/6.0;
      G[m][2][0] = 1.0/6.0;
      G[m][2][1] = 1.0/6.0;
      W[m][0] = 0.5/3.0;
      W[m][1] = 0.5/3.0;
      W[m][2] = 0.5/3.0;
      O[m] = 2;

      // polynom degree 3
      // symmetric
      m = 4;
      G[m][0][0] = 10.0/30.0;
      G[m][0][1] = 10.0/30.0;
      G[m][1][0] = 18.0/30.0;
      G[m][1][1] = 6.0/30.0;
      G[m][2][0] = 6.0/30.0;
      G[m][2][1] = 18.0/30.0;
      G[m][3][0] = 6.0/30.0;
      G[m][3][1] = 6.0/30.0;

      W[m][0] = 0.5 * -27.0/48.0;
      W[m][1] = 0.5 * 25.0/48.0;
      W[m][2] = 0.5 * 25.0/48.0;
      W[m][3] = 0.5 * 25.0/48.0;
      O[m] = 3;

      // polynomial degree 4
      // symmetric points
      m = 6;
      G[m][0][0] = 0.81684757298045851308085707319560;
      G[m][0][1] = 0.091576213509770743459571463402202;
      G[m][1][0] = 0.091576213509770743459571463402202;
      G[m][1][1] = 0.81684757298045851308085707319560;
      G[m][2][0] = 0.091576213509770743459571463402202;
      G[m][2][1] = 0.091576213509770743459571463402202;
      G[m][3][0] = 0.10810301816807022736334149223390;
      G[m][3][1] = 0.44594849091596488631832925388305;
      G[m][4][0] = 0.44594849091596488631832925388305;
      G[m][4][1] = 0.10810301816807022736334149223390;
      G[m][5][0] = 0.44594849091596488631832925388305;
      G[m][5][1] = 0.44594849091596488631832925388305;

      W[m][0] = 0.5 * 0.10995174365532186763832632490021;
      W[m][1] = 0.5 * 0.10995174365532186763832632490021;
      W[m][2] = 0.5 * 0.10995174365532186763832632490021;
      W[m][3] = 0.5 * 0.22338158967801146569500700843312;
      W[m][4] = 0.5 * 0.22338158967801146569500700843312;
      W[m][5] = 0.5 * 0.22338158967801146569500700843312;
      O[m] = 4;

      // polynomial degree 5
      // symmetric points

      m = 7;
      G[m][0][0] = 0.333333333333333333333333333333333;
      G[m][0][1] = 0.333333333333333333333333333333333;
      G[m][1][0] = 0.79742698535308732239802527616975;
      G[m][1][1] = 0.1012865073234563388009873619151;
      G[m][2][0] = 0.10128650732345633880098736191512;
      G[m][2][1] = 0.79742698535308732239802527616975;
      G[m][3][0] = 0.10128650732345633880098736191512;
      G[m][3][1] = 0.10128650732345633880098736191512;
      G[m][4][0] = 0.05971587178976982045911758097311;
      G[m][4][1] = 0.47014206410511508977044120951345;
      G[m][5][0] = 0.47014206410511508977044120951345;
      G[m][5][1] = 0.05971587178976982045911758097311;
      G[m][6][0] = 0.47014206410511508977044120951345;
      G[m][6][1] = 0.47014206410511508977044120951345;

      W[m][0] = 0.5 * 0.225;
      W[m][1] = 0.5 * 0.12593918054482715259568394550018;
      W[m][2] = 0.5 * 0.12593918054482715259568394550018;
      W[m][3] = 0.5 * 0.12593918054482715259568394550018;
      W[m][4] = 0.5 * 0.13239415278850618073764938783315;
      W[m][5] = 0.5 * 0.13239415278850618073764938783315;
      W[m][6] = 0.5 * 0.13239415278850618073764938783315;
      O[m] = 5;

      // polynomial degree 6
      /* 12 inner Gauss points, positive weights */
      m=12;
      G[m][0][0] = 0.063089014491502228340331602870819;
      G[m][0][1] = 0.063089014491502228340331602870819;
      G[m][1][0] = 0.063089014491502228340331602870819;
      G[m][1][1] = 0.87382197101699554331933679425836;
      G[m][2][0] = 0.87382197101699554331933679425836;
      G[m][2][1] = 0.063089014491502228340331602870819;
      G[m][3][0] = 0.24928674517091042129163855310702;
      G[m][3][1] = 0.24928674517091042129163855310702;
      G[m][4][0] = 0.24928674517091042129163855310702;
      G[m][4][1] = 0.50142650965817915741672289378596;
      G[m][5][0] = 0.50142650965817915741672289378596;
      G[m][5][1] = 0.24928674517091042129163855310702;
      G[m][6][0] = 0.053145049844816947353249671631398;
      G[m][6][1] = 0.31035245103378440541660773395655;
      G[m][7][0] = 0.053145049844816947353249671631398;
      G[m][7][1] = 0.63650249912139864723014259441205;
      G[m][8][0] = 0.31035245103378440541660773395655;
      G[m][8][1] = 0.053145049844816947353249671631398;
      G[m][9][0] = 0.31035245103378440541660773395655;
      G[m][9][1] = 0.63650249912139864723014259441205;
      G[m][10][0] = 0.63650249912139864723014259441205;
      G[m][10][1] = 0.053145049844816947353249671631398;
      G[m][11][0] = 0.63650249912139864723014259441205;
      G[m][11][1] = 0.31035245103378440541660773395655;

      W[m][0] = 0.5 * 0.050844906370206816920936809106869;
      W[m][1] = 0.5 * 0.050844906370206816920936809106869;
      W[m][2] = 0.5 * 0.050844906370206816920936809106869;
      W[m][3] = 0.5 * 0.11678627572637936602528961138558;
      W[m][4] = 0.5 * 0.11678627572637936602528961138558;
      W[m][5] = 0.5 * 0.11678627572637936602528961138558;
      W[m][6] = 0.5 * 0.082851075618373575193553456420442;
      W[m][7] = 0.5 * 0.082851075618373575193553456420442;
      W[m][8] = 0.5 * 0.082851075618373575193553456420442;
      W[m][9] = 0.5 * 0.082851075618373575193553456420442;
      W[m][10] = 0.5 * 0.082851075618373575193553456420442;
      W[m][11] = 0.5 * 0.082851075618373575193553456420442;
      O[m] = 6;

      // polynomial degree 7
      /* 12 inner Gauss points, positive weights */
      m=12;
      G[m][0][0] = 0.0623822650944021181736830009963499;
      G[m][0][1] = 0.0675178670739160854425571310508685;
      G[m][1][0] = 0.0675178670739160854425571310508685;
      G[m][1][1] = 0.870099867831681796383759867952782;
      G[m][2][0] = 0.870099867831681796383759867952782;
      G[m][2][1] = 0.0623822650944021181736830009963499;
      G[m][3][0] = 0.0552254566569266117374791902756449;
      G[m][3][1] = 0.321502493851981822666307849199202;
      G[m][4][0] = 0.321502493851981822666307849199202;
      G[m][4][1] = 0.623272049491091565596212960525153;
      G[m][5][0] = 0.623272049491091565596212960525153;
      G[m][5][1] = 0.0552254566569266117374791902756449;
      G[m][6][0] = 0.0343243029450971464696306424839376;
      G[m][6][1] = 0.660949196186735657611980310197799;
      G[m][7][0] = 0.660949196186735657611980310197799;
      G[m][7][1] = 0.304726500868167195918389047318263;
      G[m][8][0] = 0.304726500868167195918389047318263;
      G[m][8][1] = 0.304726500868167195918389047318263;
      G[m][9][0] = 0.515842334353591779257463386826430;
      G[m][9][1] = 0.277716166976391782569581871393723;
      G[m][10][0] = 0.277716166976391782569581871393723;
      G[m][10][1] = 0.20644149867001643817295474177985;
      G[m][11][0] = 0.20644149867001643817295474177985;
      G[m][11][1] = 0.515842334353591779257463386826430;

      W[m][0] = 0.5 * 0.053034056314872502857508360921478;
      W[m][1] = 0.5 * 0.053034056314872502857508360921478;
      W[m][2] = 0.5 * 0.053034056314872502857508360921478;
      W[m][3] = 0.5 * 0.087762817428892110073539806278575;
      W[m][4] = 0.5 * 0.087762817428892110073539806278575;
      W[m][5] = 0.5 * 0.087762817428892110073539806278575;
      W[m][6] = 0.5 * 0.057550085569963171476890993800437;
      W[m][7] = 0.5 * 0.057550085569963171476890993800437;
      W[m][8] = 0.5 * 0.057550085569963171476890993800437;
      W[m][9] = 0.5 * 0.13498637401960554892539417233284;
      W[m][10] = 0.5 * 0.13498637401960554892539417233284;
      W[m][11] = 0.5 * 0.13498637401960554892539417233284;
      O[m] = 7;

      // polynomial degree 8
      /* 16 inner Gauss points, positive weights */

      m=16;
      G[m][0][0] = 0.33333333333333333333333333333333;
      G[m][0][1] = 0.33333333333333333333333333333333;
      G[m][1][0] = 0.17056930775176020662229350149146;
      G[m][1][1] = 0.17056930775176020662229350149146;
      G[m][2][0] = 0.17056930775176020662229350149146;
      G[m][2][1] = 0.65886138449647958675541299701707;
      G[m][3][0] = 0.65886138449647958675541299701707;
      G[m][3][1] = 0.17056930775176020662229350149146;
      G[m][4][0] = 0.050547228317030975458423550596599;
      G[m][4][1] = 0.050547228317030975458423550596599;
      G[m][5][0] = 0.050547228317030975458423550596599;
      G[m][5][1] = 0.89890554336593804908315289880680;
      G[m][6][0] = 0.89890554336593804908315289880680;
      G[m][6][1] = 0.050547228317030975458423550596599;
      G[m][7][0] = 0.45929258829272315602881551449417;
      G[m][7][1] = 0.45929258829272315602881551449417;
      G[m][8][0] = 0.45929258829272315602881551449417;
      G[m][8][1] = 0.08141482341455368794236897101166;
      G[m][9][0] = 0.08141482341455368794236897101166;
      G[m][9][1] = 0.45929258829272315602881551449417;
      G[m][10][0] = 0.72849239295540428124100037917606;
      G[m][10][1] = 0.26311282963463811342178578628464;
      G[m][11][0] = 0.72849239295540428124100037917606;
      G[m][11][1] = 0.00839477740995760533721383453930;
      G[m][12][0] = 0.26311282963463811342178578628464;
      G[m][12][1] = 0.72849239295540428124100037917606;
      G[m][13][0] = 0.26311282963463811342178578628464;
      G[m][13][1] = 0.00839477740995760533721383453930;
      G[m][14][0] = 0.00839477740995760533721383453930;
      G[m][14][1] = 0.72849239295540428124100037917606;
      G[m][15][0] = 0.00839477740995760533721383453930;
      G[m][15][1] = 0.26311282963463811342178578628464;

      W[m][0] = 0.5 * 0.14431560767778716825109111048906;
      W[m][1] = 0.5 * 0.10321737053471825028179155029213;
      W[m][2] = 0.5 * 0.10321737053471825028179155029213;
      W[m][3] = 0.5 * 0.10321737053471825028179155029213;
      W[m][4] = 0.5 * 0.032458497623198080310925928341780;
      W[m][5] = 0.5 * 0.032458497623198080310925928341780;
      W[m][6] = 0.5 * 0.032458497623198080310925928341780;
      W[m][7] = 0.5 * 0.095091634267284624793896104388584;
      W[m][8] = 0.5 * 0.095091634267284624793896104388584;
      W[m][9] = 0.5 * 0.095091634267284624793896104388584;
      W[m][10] = 0.5 * 0.027230314174434994264844690073909;
      W[m][11] = 0.5 * 0.027230314174434994264844690073909;
      W[m][12] = 0.5 * 0.027230314174434994264844690073909;
      W[m][13] = 0.5 * 0.027230314174434994264844690073909;
      W[m][14] = 0.5 * 0.027230314174434994264844690073909;
      W[m][15] = 0.5 * 0.027230314174434994264844690073909;
      O[m] = 8;

      // polynomial degree 9
      /* 19 inner Gauss points, positive weights */

      m=19;
      G[m][0][0] = 0.333333333333333333333333333333333;
      G[m][0][1] = 0.333333333333333333333333333333333;
      G[m][1][0] = 0.48968251919873762778370692483619;
      G[m][1][1] = 0.48968251919873762778370692483619;
      G[m][2][0] = 0.48968251919873762778370692483619;
      G[m][2][1] = 0.02063496160252474443258615032762;
      G[m][3][0] = 0.02063496160252474443258615032762;
      G[m][3][1] = 0.48968251919873762778370692483619;
      G[m][4][0] = 0.43708959149293663726993036443535;
      G[m][4][1] = 0.43708959149293663726993036443535;
      G[m][5][0] = 0.43708959149293663726993036443535;
      G[m][5][1] = 0.12582081701412672546013927112929;
      G[m][6][0] = 0.12582081701412672546013927112929;
      G[m][6][1] = 0.43708959149293663726993036443535;
      G[m][7][0] = 0.18820353561903273024096128046733;
      G[m][7][1] = 0.18820353561903273024096128046733;
      G[m][8][0] = 0.18820353561903273024096128046733;
      G[m][8][1] = 0.62359292876193453951807743906533;
      G[m][9][0] = 0.62359292876193453951807743906533;
      G[m][9][1] = 0.18820353561903273024096128046733;
      G[m][10][0] = 0.044729513394452709865106589966276;
      G[m][10][1] = 0.044729513394452709865106589966276;
      G[m][11][0] = 0.044729513394452709865106589966276;
      G[m][11][1] = 0.91054097321109458026978682006745;
      G[m][12][0] = 0.91054097321109458026978682006745;
      G[m][12][1] = 0.044729513394452709865106589966276;
      G[m][13][0] = 0.74119859878449802069007987352342;
      G[m][13][1] = 0.036838412054736283634817598783385;
      G[m][14][0] = 0.74119859878449802069007987352342;
      G[m][14][1] = 0.22196298916076569567510252769319;
      G[m][15][0] = 0.036838412054736283634817598783385;
      G[m][15][1] = 0.74119859878449802069007987352342;
      G[m][16][0] = 0.036838412054736283634817598783385;
      G[m][16][1] = 0.22196298916076569567510252769319;
      G[m][17][0] = 0.22196298916076569567510252769319;
      G[m][17][1] = 0.74119859878449802069007987352342;
      G[m][18][0] = 0.22196298916076569567510252769319;
      G[m][18][1] = 0.036838412054736283634817598783385;

      W[m][0] = 0.5 * 0.097135796282798833819241982507289;
      W[m][1] = 0.5 * 0.031334700227139070536854831287209;
      W[m][2] = 0.5 * 0.031334700227139070536854831287209;
      W[m][3] = 0.5 * 0.031334700227139070536854831287209;
      W[m][4] = 0.5 * 0.077827541004774279316739356299404;
      W[m][5] = 0.5 * 0.077827541004774279316739356299404;
      W[m][6] = 0.5 * 0.077827541004774279316739356299404;
      W[m][7] = 0.5 * 0.079647738927210253032891774264045;
      W[m][8] = 0.5 * 0.079647738927210253032891774264045;
      W[m][9] = 0.5 * 0.079647738927210253032891774264045;
      W[m][10] = 0.5 * 0.025577675658698031261678798559000;
      W[m][11] = 0.5 * 0.025577675658698031261678798559000;
      W[m][12] = 0.5 * 0.025577675658698031261678798559000;
      W[m][13] = 0.5 * 0.043283539377289377289377289377289;
      W[m][14] = 0.5 * 0.043283539377289377289377289377289;
      W[m][15] = 0.5 * 0.043283539377289377289377289377289;
      W[m][16] = 0.5 * 0.043283539377289377289377289377289;
      W[m][17] = 0.5 * 0.043283539377289377289377289377289;
      W[m][18] = 0.5 * 0.043283539377289377289377289377289;
      O[m] = 9;

      // polynomial degree 10
      /* 25 inner Gauss points, positive weights */
      m= 25;
      G[m][0][0] = 0.333333333333333333333333333333333;
      G[m][0][1] = 0.333333333333333333333333333333333;
      G[m][1][0] = 0.42508621060209057296952951163804;
      G[m][1][1] = 0.42508621060209057296952951163804;
      G[m][2][0] = 0.42508621060209057296952951163804;
      G[m][2][1] = 0.14982757879581885406094097672391;
      G[m][3][0] = 0.14982757879581885406094097672391;
      G[m][3][1] = 0.42508621060209057296952951163804;
      G[m][4][0] = 0.023308867510000190714466386895980;
      G[m][4][1] = 0.023308867510000190714466386895980;
      G[m][5][0] = 0.023308867510000190714466386895980;
      G[m][5][1] = 0.95338226497999961857106722620804;
      G[m][6][0] = 0.95338226497999961857106722620804;
      G[m][6][1] = 0.023308867510000190714466386895980;
      G[m][7][0] = 0.62830740021349255642083766607883;
      G[m][7][1] = 0.22376697357697300622568649026820;
      G[m][8][0] = 0.62830740021349255642083766607883;
      G[m][8][1] = 0.14792562620953443735347584365296;
      G[m][9][0] = 0.22376697357697300622568649026820;
      G[m][9][1] = 0.62830740021349255642083766607883;
      G[m][10][0] = 0.22376697357697300622568649026820;
      G[m][10][1] = 0.14792562620953443735347584365296;
      G[m][11][0] = 0.14792562620953443735347584365296;
      G[m][11][1] = 0.62830740021349255642083766607883;
      G[m][12][0] = 0.14792562620953443735347584365296;
      G[m][12][1] = 0.22376697357697300622568649026820;
      G[m][13][0] = 0.61131382618139764891875500225390;
      G[m][13][1] = 0.35874014186443146457815530072385;
      G[m][14][0] = 0.61131382618139764891875500225390;
      G[m][14][1] = 0.02994603195417088650308969702225;
      G[m][15][0] = 0.35874014186443146457815530072385;
      G[m][15][1] = 0.61131382618139764891875500225390;
      G[m][16][0] = 0.35874014186443146457815530072385;
      G[m][16][1] = 0.02994603195417088650308969702225;
      G[m][17][0] = 0.02994603195417088650308969702225;
      G[m][17][1] = 0.61131382618139764891875500225390;
      G[m][18][0] = 0.02994603195417088650308969702225;
      G[m][18][1] = 0.35874014186443146457815530072385;
      G[m][19][0] = 0.82107206998562937337354441347218;
      G[m][19][1] = 0.14329537042686714530585663061732;
      G[m][20][0] = 0.82107206998562937337354441347218;
      G[m][20][1] = 0.03563255958750348132059895591050;
      G[m][21][0] = 0.14329537042686714530585663061732;
      G[m][21][1] = 0.82107206998562937337354441347218;
      G[m][22][0] = 0.14329537042686714530585663061732;
      G[m][22][1] = 0.03563255958750348132059895591050;
      G[m][23][0] = 0.03563255958750348132059895591050;
      G[m][23][1] = 0.82107206998562937337354441347218;
      G[m][24][0] = 0.03563255958750348132059895591050;
      G[m][24][1] = 0.14329537042686714530585663061732;

      W[m][0] = 0.5 * 0.079894504741239707831247045213386;
      W[m][1] = 0.5 * 0.071123802232377334639291287398658;
      W[m][2] = 0.5 * 0.071123802232377334639291287398658;
      W[m][3] = 0.5 * 0.071123802232377334639291287398658;
      W[m][4] = 0.5 * 0.0082238186904641955186466203624719;
      W[m][5] = 0.5 * 0.0082238186904641955186466203624719;
      W[m][6] = 0.5 * 0.0082238186904641955186466203624719;
      W[m][7] = 0.5 * 0.045430592296170018007073629243933;
      W[m][8] = 0.5 * 0.045430592296170018007073629243933;
      W[m][9] = 0.5 * 0.045430592296170018007073629243933;
      W[m][10] = 0.5 * 0.045430592296170018007073629243933;
      W[m][11] = 0.5 * 0.045430592296170018007073629243933;
      W[m][12] = 0.5 * 0.045430592296170018007073629243933;
      W[m][13] = 0.5 * 0.037359856234305276826236499001975;
      W[m][14] = 0.5 * 0.037359856234305276826236499001975;
      W[m][15] = 0.5 * 0.037359856234305276826236499001975;
      W[m][16] = 0.5 * 0.037359856234305276826236499001975;
      W[m][17] = 0.5 * 0.037359856234305276826236499001975;
      W[m][18] = 0.5 * 0.037359856234305276826236499001975;
      W[m][19] = 0.5 * 0.030886656884563988782513077004629;
      W[m][20] = 0.5 * 0.030886656884563988782513077004629;
      W[m][21] = 0.5 * 0.030886656884563988782513077004629;
      W[m][22] = 0.5 * 0.030886656884563988782513077004629;
      W[m][23] = 0.5 * 0.030886656884563988782513077004629;
      W[m][24] = 0.5 * 0.030886656884563988782513077004629;
      O[m] = 10;

      // polynomial degree 11
      /* 28 inner Gauss points, positive weights */

      m=28;
      G[m][0][0] = 0.858870281282636704039173938058347;
      G[m][0][1] = 0.141129718717363295960826061941652;
      G[m][1][0] = 0.858870281282636704039173938058347;
      G[m][1][1] = 0.0;
      G[m][2][0] = 0.141129718717363295960826061941652;
      G[m][2][1] = 0.858870281282636704039173938058347;
      G[m][3][0] = 0.141129718717363295960826061941652;
      G[m][3][1] = 0.0;
      G[m][4][0] = 0.0;
      G[m][4][1] = 0.858870281282636704039173938058347;
      G[m][5][0] = 0.0;
      G[m][5][1] = 0.141129718717363295960826061941652;
      G[m][6][0] = 0.333333333333333333333333333333333;
      G[m][6][1] = 0.333333333333333333333333333333333;
      G[m][7][0] = 0.025989140928287395260032485498841;
      G[m][7][1] = 0.025989140928287395260032485498841;
      G[m][8][0] = 0.025989140928287395260032485498841;
      G[m][8][1] = 0.94802171814342520947993502900232;
      G[m][9][0] = 0.94802171814342520947993502900232;
      G[m][9][1] = 0.025989140928287395260032485498841;
      G[m][10][0] = 0.094287502647922495630569776275405;
      G[m][10][1] = 0.094287502647922495630569776275405;
      G[m][11][0] = 0.094287502647922495630569776275405;
      G[m][11][1] = 0.81142499470415500873886044744919;
      G[m][12][0] = 0.81142499470415500873886044744919;
      G[m][12][1] = 0.094287502647922495630569776275405;
      G[m][13][0] = 0.49463677501721381374163260230644;
      G[m][13][1] = 0.49463677501721381374163260230644;
      G[m][14][0] = 0.49463677501721381374163260230644;
      G[m][14][1] = 0.01072644996557237251673479538713;
      G[m][15][0] = 0.01072644996557237251673479538713;
      G[m][15][1] = 0.49463677501721381374163260230644;
      G[m][16][0] = 0.20734338261451133345293402411297;
      G[m][16][1] = 0.20734338261451133345293402411297;
      G[m][17][0] = 0.20734338261451133345293402411297;
      G[m][17][1] = 0.58531323477097733309413195177407;
      G[m][18][0] = 0.58531323477097733309413195177407;
      G[m][18][1] = 0.20734338261451133345293402411297;
      G[m][19][0] = 0.43890780570049209506106538163613;
      G[m][19][1] = 0.43890780570049209506106538163613;
      G[m][20][0] = 0.43890780570049209506106538163613;
      G[m][20][1] = 0.12218438859901580987786923672775;
      G[m][21][0] = 0.12218438859901580987786923672775;
      G[m][21][1] = 0.43890780570049209506106538163613;
      G[m][22][0] = 0.67793765488259040154212614118875;
      G[m][22][1] = 0.044841677589130443309052391468801;
      G[m][23][0] = 0.67793765488259040154212614118875;
      G[m][23][1] = 0.27722066752827915514882146734245;
      G[m][24][0] = 0.044841677589130443309052391468801;
      G[m][24][1] = 0.67793765488259040154212614118875;
      G[m][25][0] = 0.044841677589130443309052391468801;
      G[m][25][1] = 0.27722066752827915514882146734245;
      G[m][26][0] = 0.27722066752827915514882146734245;
      G[m][26][1] = 0.67793765488259040154212614118875;
      G[m][27][0] = 0.27722066752827915514882146734245;
      G[m][27][1] = 0.044841677589130443309052391468801;

      W[m][0] = 0.5 * 0.0073623837833005542642588950473806;
      W[m][1] = 0.5 * 0.0073623837833005542642588950473806;
      W[m][2] = 0.5 * 0.0073623837833005542642588950473806;

      W[m][3] = 0.5 * 0.0073623837833005542642588950473806;
      W[m][4] = 0.5 * 0.0073623837833005542642588950473806;
      W[m][5] = 0.5 * 0.0073623837833005542642588950473806;

      W[m][6] = 0.5 * 0.087977301162232238798093169321456;
      W[m][7] = 0.5 * 0.0087443115537360230495164287998252;
      W[m][8] = 0.5 * 0.0087443115537360230495164287998252;
      W[m][9] = 0.5 * 0.0087443115537360230495164287998252;

      W[m][10] = 0.5 * 0.038081571993934937515024339435614;
      W[m][11] = 0.5 * 0.038081571993934937515024339435614;
      W[m][12] = 0.5 * 0.038081571993934937515024339435614;

      W[m][13] = 0.5 * 0.018855448056131292058476782591115;
      W[m][14] = 0.5 * 0.018855448056131292058476782591115;
      W[m][15] = 0.5 * 0.018855448056131292058476782591115;

      W[m][16] = 0.5 * 0.072159697544739526124029988586463;
      W[m][17] = 0.5 * 0.072159697544739526124029988586463;
      W[m][18] = 0.5 * 0.072159697544739526124029988586463;

      W[m][19] = 0.5 * 0.069329138705535899841765650903814;
      W[m][20] = 0.5 * 0.069329138705535899841765650903814;
      W[m][21] = 0.5 * 0.069329138705535899841765650903814;

      W[m][22] = 0.5 * 0.041056315429288566641652314907294;
      W[m][23] = 0.5 * 0.041056315429288566641652314907294;
      W[m][24] = 0.5 * 0.041056315429288566641652314907294;

      W[m][25] = 0.5 * 0.041056315429288566641652314907294;
      W[m][26] = 0.5 * 0.041056315429288566641652314907294;
      W[m][27] = 0.5 * 0.041056315429288566641652314907294;
      O[m] = 11;

      // polynomial degree 12
      /* 33 inner Gauss points, positive weights */
      m=33;
      G[m][0][0] = 0.02356522045239;
      G[m][0][1] = 0.488217389773805;
      G[m][1][0] = 0.488217389773805;
      G[m][1][1] = 0.02356522045239;
      G[m][2][0] = 0.488217389773805;
      G[m][2][1] = 0.488217389773805;
      G[m][3][0] = 0.43972439229446;
      G[m][3][1] = 0.43972439229446;
      G[m][4][0] = 0.43972439229446;
      G[m][4][1] = 0.120551215411079;
      G[m][5][0] = 0.120551215411079;
      G[m][5][1] = 0.43972439229446;
      G[m][6][0] = 0.271210385012116;
      G[m][6][1] = 0.271210385012116;
      G[m][7][0] = 0.271210385012116;
      G[m][7][1] = 0.457579229975768;
      G[m][8][0] = 0.457579229975768;
      G[m][8][1] = 0.271210385012116;
      G[m][9][0] = 0.127576145541586;
      G[m][9][1] = 0.127576145541586;
      G[m][10][0] = 0.127576145541586;
      G[m][10][1] = 0.7448477089168279;
      G[m][11][0] = 0.7448477089168279;
      G[m][11][1] = 0.127576145541586;
      G[m][12][0] = 0.02131735045321;
      G[m][12][1] = 0.02131735045321;
      G[m][13][0] = 0.02131735045321;
      G[m][13][1] = 0.9573652990935799;
      G[m][14][0] = 0.9573652990935799;
      G[m][14][1] = 0.02131735045321;
      G[m][15][0] = 0.115343494534698;
      G[m][15][1] = 0.275713269685514;
      G[m][16][0] = 0.115343494534698;
      G[m][16][1] = 0.6089432357797879;
      G[m][17][0] = 0.275713269685514;
      G[m][17][1] = 0.115343494534698;
      G[m][18][0] = 0.275713269685514;
      G[m][18][1] = 0.6089432357797879;
      G[m][19][0] = 0.6089432357797879;
      G[m][19][1] = 0.115343494534698;
      G[m][20][0] = 0.6089432357797879;
      G[m][20][1] = 0.275713269685514;
      G[m][21][0] = 0.022838332222257;
      G[m][21][1] = 0.28132558098994;
      G[m][22][0] = 0.022838332222257;
      G[m][22][1] = 0.6958360867878031;
      G[m][23][0] = 0.28132558098994;
      G[m][23][1] = 0.022838332222257;
      G[m][24][0] = 0.28132558098994;
      G[m][24][1] = 0.6958360867878031;
      G[m][25][0] = 0.6958360867878031;
      G[m][25][1] = 0.022838332222257;
      G[m][26][0] = 0.6958360867878031;
      G[m][26][1] = 0.28132558098994;
      G[m][27][0] = 0.02573405054833;
      G[m][27][1] = 0.116251915907597;
      G[m][28][0] = 0.02573405054833;
      G[m][28][1] = 0.858014033544073;
      G[m][29][0] = 0.116251915907597;
      G[m][29][1] = 0.02573405054833;
      G[m][30][0] = 0.116251915907597;
      G[m][30][1] = 0.858014033544073;
      G[m][31][0]= 0.858014033544073;
      G[m][31][1] =0.02573405054833;
      G[m][32][0] =0.858014033544073;
      G[m][32][1]= 0.116251915907597;

      W[m][0] = 0.5 * 0.025731066440455;
      W[m][1] = 0.5 * 0.025731066440455;
      W[m][2] = 0.5 * 0.025731066440455;
      W[m][3] = 0.5 * 0.043692544538038;
      W[m][4] = 0.5 * 0.043692544538038;
      W[m][5] = 0.5 * 0.043692544538038;
      W[m][6] = 0.5 * 0.062858224217885;
      W[m][7] = 0.5 * 0.062858224217885;
      W[m][8] = 0.5 * 0.062858224217885;
      W[m][9] = 0.5 * 0.034796112930709;
      W[m][10] = 0.5 * 0.034796112930709;
      W[m][11] = 0.5 * 0.034796112930709;
      W[m][12] = 0.5 * 0.006166261051559;
      W[m][13] = 0.5 * 0.006166261051559;
      W[m][14] = 0.5 * 0.006166261051559;
      W[m][15] = 0.5 * 0.040371557766381;
      W[m][16] = 0.5 * 0.040371557766381;
      W[m][17] = 0.5 * 0.040371557766381;
      W[m][18] = 0.5 * 0.040371557766381;
      W[m][19] = 0.5 * 0.040371557766381;
      W[m][20] = 0.5 * 0.040371557766381;
      W[m][21] = 0.5 * 0.022356773202303;
      W[m][22] = 0.5 * 0.022356773202303;
      W[m][23] = 0.5 * 0.022356773202303;
      W[m][24] = 0.5 * 0.022356773202303;
      W[m][25] = 0.5 * 0.022356773202303;
      W[m][26] = 0.5 * 0.022356773202303;
      W[m][27] = 0.5 * 0.017316231108659;
      W[m][28] = 0.5 * 0.017316231108659;
      W[m][29] = 0.5 * 0.017316231108659;
      W[m][30] = 0.5 * 0.017316231108659;
      W[m][31] = 0.5 * 0.017316231108659;
      W[m][32] = 0.5 * 0.017316231108659;
      O[m] = 12;
    }

    FieldVector<double, 2> point(int m, int i)
    {
      return G[m][i];
    }

    double weight (int m, int i)
    {
      return W[m][i];
    }

    int order (int m)
    {
      return O[m];
    }

  private:
    FieldVector<double, 2> G[MAXP+1][MAXP];

    double W[MAXP+1][MAXP];     // weights associated with points
    int O[MAXP+1];              // order of the rule
  };


  /** Singleton holding the Gauss points on the interval */
  template<int dim>
  struct SimplexQuadraturePointsSingleton {
    static SimplexQuadraturePoints<dim> sqp;
  };

  template<>
  struct SimplexQuadraturePointsSingleton<2> {
    static SimplexQuadraturePoints<2> sqp;
  };


  template<typename ct, int dim>
  class SimplexQuadratureRule;

  template<typename ct>
  class SimplexQuadratureRule<ct,2> : public QuadratureRule<ct,2>
  {
  public:
    enum {d=2};
    enum {highest_order=SimplexQuadraturePoints<2>::highest_order};
    typedef ct CoordType;
    typedef SimplexQuadratureRule value_type;
    SimplexQuadratureRule(int p)
    {
      switch(p)
      {
      case 0 :  // to be verified
        m=1;   // to be verified
        break;
      case 1 :
        m=1;
        break;
      case 2 :
        m=3;
        break;
      case 3 :
        m=4;
        break;
      case 4 :
        m=6;
        break;
      case 5 :
        m=7;
        break;
      case 6 :
        m=12;
        break;
      case 7 :
        m=12;
        break;
      case 8 :
        m=16;
        break;
      case 9 :
        m=19;
        break;
      case 10 :
        m=25;
        break;
      case 11 :
        m=28;
        break;
      case 12 :
        m=33;
        break;
      default : m=33;
      }
      delivered_order = SimplexQuadraturePointsSingleton<2>::sqp.order(m);
      FieldVector<ct, d> local;
      double weight;
      for(int i=0; i<m; ++i)
      {
        for(int k=0; k<d; ++k)
          local[k]=SimplexQuadraturePointsSingleton<2>::sqp.point(m,i)[k];
        weight=SimplexQuadraturePointsSingleton<2>::sqp.weight(m,i);
        // put in container
        push_back(QuadraturePoint<ct,d>(local,weight));

      }

    }

    //! return order
    int order () const
    {
      return delivered_order;
    }

    //! return type of element
    GeometryType type () const
    {
      static const GeometryType simplex (GeometryType::simplex, d);
      return simplex;
    }

    //! appear as your own container
    const SimplexQuadratureRule<ct,2>& getelement (GeometryType type, int p)
    {
      return *this;
    }
    ~SimplexQuadratureRule(){}


  private:
    int delivered_order, m;
  };



  /***********************************************************
  * Gauss quadrature for Simplices/ tetrahedron
  ***********************************************************/
  template<int dim>
  class SimplexQuadraturePoints;

  template<>
  class SimplexQuadraturePoints<3>
  //!
  {
  public:
    enum { MAXP=15};
    enum { highest_order=5 };

    //! initialize quadrature points on the interval for all orders
    SimplexQuadraturePoints()
    {
      int m = 0;
      O[m] = 0;

      // polynom degree 1
      m = 1;
      G[m][0][0] = 0.25;
      G[m][0][1] = 0.25;
      G[m][0][2] = 0.25;

      W[m][0] = 1.0/6.0;
      O[m] = 1;

      // polynom degree 2
      // symmetric
      m = 4;
      G[m][0][0] = 0.58541020;
      G[m][0][1] = 0.13819660;
      G[m][0][2] = 0.13819660;
      G[m][1][0] = 0.13819660;
      G[m][1][1] = 0.58541020;
      G[m][1][2] = 0.13819660;
      G[m][2][0] = 0.13819660;
      G[m][2][1] = 0.13819660;
      G[m][2][2] = 0.58541020;
      G[m][3][0] = 0.13819660;
      G[m][3][1] = 0.13819660;
      G[m][3][2] = 0.13819660;

      W[m][0] = 1.0/4.0/6.0;
      W[m][1] = 1.0/4.0/6.0;
      W[m][2] = 1.0/4.0/6.0;
      W[m][3] = 1.0/4.0/6.0;
      O[m] = 2;

      // polynom degree 3
      // symmetric
      m = 8;
      G[m][0][0] = 0.0;
      G[m][0][1] = 0.0;
      G[m][0][2] = 0.0;
      G[m][1][0] = 1.0;
      G[m][1][1] = 0.0;
      G[m][1][2] = 0.0;
      G[m][2][0] = 0.0;
      G[m][2][1] = 1.0;
      G[m][2][2] = 0.0;
      G[m][3][0] = 0.0;
      G[m][3][1] = 0.0;
      G[m][3][2] = 1.0;
      G[m][4][0] = 0.333333333333;
      G[m][4][1] = 0.333333333333;
      G[m][4][2] = 0.0;
      G[m][5][0] = 0.333333333333;
      G[m][5][1] = 0.0;
      G[m][5][2] = 0.333333333333;
      G[m][6][0] = 0.0;
      G[m][6][1] = 0.333333333333;
      G[m][6][2] = 0.333333333333;
      G[m][7][0] = 0.333333333333;
      G[m][7][1] = 0.333333333333;
      G[m][7][2] = 0.333333333333;
      W[m][0] = 0.025/6.0;
      W[m][1] = 0.025/6.0;
      W[m][2] = 0.025/6.0;
      W[m][3] = 0.025/6.0;
      W[m][4] = 0.225/6.0;
      W[m][5] = 0.225/6.0;
      W[m][6] = 0.225/6.0;
      W[m][7] = 0.225/6.0;
      O[m] = 3;


      // polynomial degree 5
      // symmetric points
      m=15;
      G[m][0][0] = 0.25;
      G[m][0][1] = 0.25;
      G[m][0][2] = 0.25;
      G[m][1][0] = 0.091971078;
      G[m][1][1] = 0.091971078;
      G[m][1][2] = 0.091971078;
      G[m][2][0] = 0.72408677;
      G[m][2][1] = 0.091971078;
      G[m][2][2] = 0.091971078;
      G[m][3][0] = 0.31979363;
      G[m][3][1] = 0.72408677;
      G[m][3][2] = 0.31979363;
      G[m][4][0] = 0.31979363;
      G[m][4][1] = 0.31979363;
      G[m][4][2] = 0.72408677;
      G[m][5][0] = 0.31979363;
      G[m][5][1] = 0.31979363;
      G[m][5][2] = 0.31979363;
      G[m][6][0] = 0.040619117;
      G[m][6][1] = 0.31979363;
      G[m][6][2] = 0.31979363;
      G[m][7][0] = 0.31979363;
      G[m][7][1] = 0.040619117;
      G[m][7][2] = 0.31979363;
      G[m][8][0] = 0.3197936;
      G[m][8][1] = 0.3197936;
      G[m][8][2] = 0.040619117;
      G[m][9][0] = 0.44364917;
      G[m][9][1] = 0.056350833;
      G[m][9][2] = 0.056350833;
      G[m][10][0] = 0.056350833;
      G[m][10][1] = 0.44364917;
      G[m][10][2] = 0.056350833;
      G[m][11][0] = 0.056350833;
      G[m][11][1] = 0.056350833;
      G[m][11][2] = 0.44364917;
      G[m][12][0] = 0.44364917;
      G[m][12][1] = 0.44364917;
      G[m][12][2] = 0.056350833;
      G[m][13][0] = 0.44364917;
      G[m][13][1] = 0.056350833;
      G[m][13][2] = 0.44364917;
      G[m][14][0] = 0.056350833;
      G[m][14][1] = 0.44364917;
      G[m][14][2] =0.44364917;

      W[m][0] = 0.11851852/6.0;
      W[m][1] = 0.071937084/6.0;
      W[m][2] = 0.071937084/6.0;
      W[m][3] = 0.071937084/6.0;
      W[m][4] = 0.071937084/6.0;
      W[m][5] = 0.0690682070/6.0;
      W[m][6] = 0.0690682070/6.0;
      W[m][7] = 0.0690682070/6.0;
      W[m][8] = 0.069068207/6.0;
      W[m][9] = 0.052910053/6.0;
      W[m][10] = 0.052910053/6.0;
      W[m][11] = 0.052910053/6.0;
      W[m][12] = 0.052910053/6.0;
      W[m][13] = 0.052910053/6.0;
      W[m][14] = 0.052910053/6.0;
      O[m] = 5;

    }

    FieldVector<double, 3> point(int m, int i)
    {
      return G[m][i];
    }

    double weight (int m, int i)
    {
      return W[m][i];
    }

    int order (int m)
    {
      return O[m];
    }

  private:
    FieldVector<double, 3> G[MAXP+1][MAXP];
    double W[MAXP+1][MAXP];     // weights associated with points
    int O[MAXP+1];              // order of the rule
  };


  /** Singleton holding the SimplexQuadrature points dim==3 */
  template<>
  struct SimplexQuadraturePointsSingleton<3> {
    static SimplexQuadraturePoints<3> sqp;
  };


  template<typename ct, int dim>
  class SimplexQuadratureRule;

  template<typename ct>
  class SimplexQuadratureRule<ct,3> : public QuadratureRule<ct,3>
  {

  public:
    enum {d=3};
    enum {highest_order=SimplexQuadraturePoints<3>::highest_order};
    typedef ct CoordType;
    typedef SimplexQuadratureRule<ct,3> value_type;
    SimplexQuadratureRule(int p)
    {
      switch(p)
      {
      case 0 :  // to be verified
        m=1;   // to be verified
        break;
      case 1 :
        m=1;
        break;
      case 2 :
        m=4;
        break;
      case 3 :
        m=8;
        break;
      case 4 :
      case 5 :
        m=15;
        break;
      default : m=15;
      }
      delivered_order = SimplexQuadraturePointsSingleton<3>::sqp.order(m);
      FieldVector<ct, d> local;
      double weight;
      for(int i=0; i<m; ++i)
      {
        for(int k=0; k<d; ++k)
          local[k]=SimplexQuadraturePointsSingleton<3>::sqp.point(m,i)[k];
        weight=SimplexQuadraturePointsSingleton<3>::sqp.weight(m,i);
        // put in container
        push_back(QuadraturePoint<ct,d>(local,weight));

      }

    }

    //! return order
    int order () const
    {
      return delivered_order;
    }

    //! return type of element
    GeometryType type () const
    {
      static const GeometryType simplex (GeometryType::simplex, d);
      return simplex;
    }

    //! appear as your own container
    const SimplexQuadratureRule<ct,d>& getelement (GeometryType type, int p)
    {
      return *this;
    }

    ~SimplexQuadratureRule(){}
  private:
    int delivered_order, m;
  };



  /***********************************
   * quadrature for Prism
   **********************************/

  //!
  template<int dim>
  class PrismQuadraturePoints;

  template<>
  class PrismQuadraturePoints<3>
  {
  public:
    enum { MAXP=6};
    enum { highest_order=2 };

    //! initialize quadrature points on the interval for all orders
    PrismQuadraturePoints ()
    {
      int m = 0;
      O[m] = 0;

      // polynom degree 0  ???
      m = 6;
      G[m][0][0] = 0.0;
      G[m][0][1] = 0.0;
      G[m][0][2] = 0.0;

      G[m][1][0] = 1.0;
      G[m][1][1] = 0.0;
      G[m][1][2] = 0.0;

      G[m][2][0] = 0.0;
      G[m][2][1] = 1.0;
      G[m][2][2] = 0.0;

      G[m][3][0] = 0.0;
      G[m][3][1] = 0.0;
      G[m][3][2] = 1.0;

      G[m][4][0] = 1.0;
      G[m][4][1] = 0.0;
      G[m][4][2] = 1.0;

      G[m][5][0] = 0.0;
      G[m][5][1] = 0.1;
      G[m][5][2] = 1.0;

      W[m][0] = 0.16666666666666666 / 2.0;
      W[m][1] = 0.16666666666666666 / 2.0;
      W[m][2] = 0.16666666666666666 / 2.0;
      W[m][3] = 0.16666666666666666 / 2.0;
      W[m][4] = 0.16666666666666666 / 2.0;
      W[m][5] = 0.16666666666666666 / 2.0;

      O[m] = 0;  // verify ????????


      // polynom degree 2  ???
      m = 6;
      G[m][0][0] =0.66666666666666666 ;
      G[m][0][1] =0.16666666666666666 ;
      G[m][0][2] =0.211324865405187 ;

      G[m][1][0] = 0.16666666666666666;
      G[m][1][1] =0.66666666666666666 ;
      G[m][1][2] = 0.211324865405187;

      G[m][2][0] = 0.16666666666666666;
      G[m][2][1] = 0.16666666666666666;
      G[m][2][2] = 0.211324865405187;

      G[m][3][0] = 0.66666666666666666;
      G[m][3][1] = 0.16666666666666666;
      G[m][3][2] = 0.788675134594813;

      G[m][4][0] = 0.16666666666666666;
      G[m][4][1] = 0.66666666666666666;
      G[m][4][2] = 0.788675134594813;

      G[m][5][0] = 0.16666666666666666;
      G[m][5][1] = 0.16666666666666666;
      G[m][5][2] = 0.788675134594813;

      W[m][0] = 0.16666666666666666 / 2.0;
      W[m][1] = 0.16666666666666666 / 2.0;
      W[m][2] = 0.16666666666666666 / 2.0;
      W[m][3] = 0.16666666666666666 / 2.0;
      W[m][4] = 0.16666666666666666 / 2.0;
      W[m][5] = 0.16666666666666666 / 2.0;

      O[m] = 2;  // verify ????????

    }

    FieldVector<double, 3> point(int m, int i)
    {
      return G[m][i];
    }

    double weight (int m, int i)
    {
      return W[m][i];
    }

    int order (int m)
    {
      return O[m];
    }

  private:
    FieldVector<double, 3> G[MAXP+1][MAXP]; //positions

    double W[MAXP+1][MAXP];     // weights associated with points
    int O[MAXP+1];              // order of the rule
  };


  /** Singleton holding the Prism Quadrature points  */
  template<int dim>
  struct PrismQuadraturePointsSingleton {
    static PrismQuadraturePoints<3> prqp;
  };
  template<>
  struct PrismQuadraturePointsSingleton<3> {
    static PrismQuadraturePoints<3> prqp;
  };

  template<typename ct, int dim>
  class PrismQuadratureRule;

  template<typename ct>
  class PrismQuadratureRule<ct,3> : public QuadratureRule<ct,3>
  {
  public:
    enum { d=3 };
    enum {
      /* min(Line::order, Triangle::order) */
      highest_order =
        (int)CubeQuadratureRule<ct,1>::highest_order
        < (int)SimplexQuadratureRule<ct,2>::highest_order
        ? (int)CubeQuadratureRule<ct,1>::highest_order
        : (int)SimplexQuadratureRule<ct,2>::highest_order
    };
    typedef ct CoordType;
    typedef PrismQuadratureRule<ct,3> value_type;
    PrismQuadratureRule(int p)
    {
      if (p<=2) {
        int m=6;
        delivered_order = PrismQuadraturePointsSingleton<3>::prqp.order(m);
        for(int i=0; i<m; ++i)
        {
          FieldVector<ct,3> local;
          for (int k=0; k<d; k++)
            local[k] = PrismQuadraturePointsSingleton<3>::prqp.point(m,i)[k];
          double weight =
            PrismQuadraturePointsSingleton<3>::prqp.weight(m,i);
          // put in container
          push_back(QuadraturePoint<ct,d>(local,weight));
        }
      }
      else {
        SimplexQuadratureRule<ct,2> triangle(p);
        CubeQuadratureRule<ct,1> line(p);

        delivered_order = std::min(triangle.order(),line.order());

        for (typename CubeQuadratureRule<ct,1>::iterator
             lit = line.begin(); lit != line.end(); ++lit)
        {
          for (typename SimplexQuadratureRule<ct,2>::iterator
               tit = triangle.begin(); tit != triangle.end(); ++tit)
          {
            FieldVector<ct, d> local;
            local[0] = tit->position()[0];
            local[1] = tit->position()[1];
            local[2] = lit->position()[0];

            double weight = tit->weight() * lit->weight();

            // put in container
            push_back(QuadraturePoint<ct,d>(local,weight));
          }
        }
      }
    }

    //! return order
    int order () const
    {
      return delivered_order;
    }

    //! return type of element
    GeometryType type () const
    {
      static const GeometryType prism (GeometryType::prism, d);
      return prism;
    }

    //! appear as your own container
    const PrismQuadratureRule<ct,3>& getelement (GeometryType type, int p)
    {
      return *this;
    }
    ~PrismQuadratureRule(){}

  private:
    int delivered_order;
  };

  /***********************************************************
  *   quadrature for Pyramid
  ***********************************************************/

  //!
  template<int dim>
  class PyramidQuadraturePoints;

  template<>
  class PyramidQuadraturePoints<3>
  {
  public:
    enum { MAXP=8};
    enum { highest_order=2 };

    //! initialize quadrature points on the interval for all orders
    PyramidQuadraturePoints()
    {
      int m = 0;
      O[m] = 0;


      // polynom degree 2  ???
      m = 8;
      G[m][0][0] =0.58541020;
      G[m][0][1] =0.72819660;
      G[m][0][2] =0.13819660;

      G[m][1][0] =0.13819660;
      G[m][1][1] =0.72819660;
      G[m][1][2] =0.13819660;

      G[m][2][0] =0.13819660;
      G[m][2][1] =0.27630920;
      G[m][2][2] =0.58541020;

      G[m][3][0] =0.13819660;
      G[m][3][1] =0.27630920;
      G[m][3][2] =0.13819660;

      G[m][4][0] =0.72819660;
      G[m][4][1] =0.13819660;
      G[m][4][2] =0.13819660;

      G[m][5][0] =0.72819660;
      G[m][5][1] =0.58541020;
      G[m][5][2] =0.13819660;

      G[m][6][0] =0.27630920;
      G[m][6][1] =0.13819660;
      G[m][6][2] =0.58541020;

      G[m][7][0] =0.27630920;
      G[m][7][1] =0.13819660;
      G[m][7][2] =0.13819660;

      W[m][0] = 0.125 / 3.0;
      W[m][1] = 0.125 / 3.0;
      W[m][2] = 0.125 / 3.0;
      W[m][3] = 0.125 / 3.0;
      W[m][4] = 0.125 / 3.0;
      W[m][5] = 0.125 / 3.0;
      W[m][6] = 0.125 / 3.0;
      W[m][7] = 0.125 / 3.0;

      O[m] = 2;  // verify ????????

    }

    FieldVector<double, 3> point(int m, int i)
    {
      return G[m][i];
    }

    double weight (int m, int i)
    {
      return W[m][i];
    }

    int order (int m)
    {
      return O[m];
    }

  private:
    FieldVector<double, 3> G[MAXP+1][MAXP];
    //double G[MAXP+1][MAXP]; // positions of Gauss points
    double W[MAXP+1][MAXP];     // weights associated with points
    int O[MAXP+1];              // order of the rule
  };


  /** Singleton holding the Quadrature  points  */

  template<int dim>
  struct PyramidQuadraturePointsSingleton {
    static PyramidQuadraturePoints<3> pyqp;
  };
  template<>
  struct PyramidQuadraturePointsSingleton<3> {
    static PyramidQuadraturePoints<3> pyqp;
  };

  template<typename ct, int dim>
  class PyramidQuadratureRule;

  template<typename ct>
  class PyramidQuadratureRule<ct,3> : public QuadratureRule<ct,3>
  {
  public:
    enum {d=3};
    enum {highest_order=PyramidQuadraturePoints<3>::highest_order};
    typedef ct CoordType;
    typedef PyramidQuadratureRule<ct,3> value_type;
    PyramidQuadratureRule(int p)
    {
      switch(p)
      {
      default : m=8;
      }

      delivered_order = PyramidQuadraturePointsSingleton<3>::pyqp.order(m);
      FieldVector<ct, d> local;
      double weight;
      for(int i=0; i<m; ++i)
      {
        for(int k=0; k<d; ++k)
          local[k]=PyramidQuadraturePointsSingleton<3>::pyqp.point(m,i)[k];
        weight=PyramidQuadraturePointsSingleton<3>::pyqp.weight(m,i);
        // put in container
        push_back(QuadraturePoint<ct,d>(local,weight));
      }
    }

    //! return order
    int order () const
    {
      return delivered_order;
    }

    //! return type of element
    GeometryType type () const
    {
      static const GeometryType pyramid (GeometryType::pyramid, d);
      return pyramid;
    }

    //! appear as your own container
    const PyramidQuadratureRule<ct,3>& getelement (GeometryType type, int p)
    {
      return *this;
    }
    ~PyramidQuadratureRule(){}

  private:
    int delivered_order, m;
  };



  /***********************************************************
  * The general container and the singleton
  ***********************************************************/

  //! A container for all quadrature rules
  template<typename ct, int dim>
  class QuadratureRuleContainer
  {
  public:
    typedef QuadratureRule<ct,dim> value_type;

    //! make rules for all element types up to given order
    QuadratureRuleContainer (int pmax)
    {
      // initialize index counter for rules in the array
      int index=0;
      int cubeindex=0;
      int simpindex=0;

      ////////////////////////
      // the cube rules
      ////////////////////////

      // allocate all rules up to requested order
      for (int p=1; p<=CubeQuadratureRule<ct,dim>::highest_order; p++)
      {
        if (p<=pmax)
        {
          QuadratureRule<ct,dim>* pointer = new CubeQuadratureRule<ct,dim>(p);
          rules.push_back(pointer);
          cube_order_to_index[p] = index;
          index++;
          cubeindex=index;
        }
        else break;
      }

      ////////////
      // simplex rule
      /////////

      for (int m=1; m<=SimplexQuadraturePoints<dim>::MAXP; m++)
      {
        int p = SimplexQuadraturePointsSingleton<dim>::sqp.order(m);       // order of rule with m points
        if (p<=pmax)
        {
          QuadratureRule<ct,dim>* pointer = new SimplexQuadratureRule<ct,dim>(p);
          rules.push_back(pointer);
          if (m==1)
            for (int i=0; i<=SimplexQuadraturePoints<dim>::highest_order; i++)
              simplex_order_to_index[i] = index;
          else
            for (int i=0; i<=SimplexQuadraturePoints<dim>::highest_order; i++)
              if (rules[simplex_order_to_index[i]]->order()<i)
                simplex_order_to_index[i] = index;

          ++index;
          simpindex=index;
        }
        else break;
      }


      // check if order can be achieved

      cube_maxorder = rules[cubeindex-1]->order();
      if (cube_maxorder<pmax)
        dverb << "Warning: Quadrature rule order " << pmax
              << " requested for cubes but only " << cube_maxorder << " available" << std::endl;

      simplex_maxorder = rules[simpindex-1]->order();
      if(simplex_maxorder<pmax)
        dverb << "Warning: Quadrature rule order " << pmax
              << " requested for simplex-" << dim <<"D"<<" but only " << simplex_maxorder << " available" << std::endl;

    }


    //! select the appropriate rule
    const QuadratureRule<ct,dim>& operator() (GeometryType type, int p)
    {
      if (type.isCube())
      {
        if (p>=1 && p<=cube_maxorder)
          return *(rules[cube_order_to_index[p]]);
      }
      if (type.isSimplex())
      {
        if(dim>=2 && p>=1 && p<=simplex_maxorder)
          return *(rules[simplex_order_to_index[p]]);
      }

      DUNE_THROW(QuadratureOrderOutOfRange,
                 "QuadratureRule for order " << p << " and GeometryType "
                                             << type << " not available");
    }

    ~QuadratureRuleContainer()
    {
      typedef typename std::vector<QuadratureRule<ct,dim>*>::iterator Iterator;
      for(Iterator entry = rules.begin(); entry != rules.end(); ++entry)
        delete (*entry);
    }

    //! ConstIterator class for sequential access
    class const_iterator
    {
    public:
      //! construct from stl iterator
      const_iterator (const typename std::vector<QuadratureRule<ct,dim>*>::const_iterator& _i) : i(_i)
      {       }

      //! prefix increment
      const_iterator& operator++()
      {
        ++i;
        return *this;
      }

      //! prefix decrement
      const_iterator& operator--()
      {
        --i;
        return *this;
      }

      //! equality
      bool operator== (const const_iterator& it) const
      {
        return i==it.i;
      }

      //! inequality
      bool operator!= (const const_iterator& it) const
      {
        return i!=it.i;
      }

      //! dereferencing
      const QuadratureRule<ct,dim>& operator* () const
      {
        return **i;
      }

      //! arrow
      const QuadratureRule<ct,dim>* operator-> () const
      {
        return *i;
      }

    private:
      typename std::vector<QuadratureRule<ct,dim>*>::const_iterator i;
    };

    const_iterator begin ()
    {
      return const_iterator(rules.begin());
    }

    const_iterator end ()
    {
      return const_iterator(rules.end());
    }

  private:
    // the vector of all rules
    std::vector<QuadratureRule<ct,dim>*> rules;

    // mapping for cube rules
    int cube_maxorder;
    int simplex_maxorder;
    int cube_order_to_index[CubeQuadratureRule<ct,1>::highest_order+1];
    int simplex_order_to_index[SimplexQuadraturePoints<dim>::highest_order+1];
  };

  /*-----------------------------------
     Specialization for 1D simplex
     if instantiated 1D simplex,
     it use ID cube quadrature rule
   * General container and singletons
     --------------------------------*/

  //! A container for all quadrature rules
  template<typename ct>
  class QuadratureRuleContainer<ct,1>
  {
    enum { dim=1 };
  public:
    typedef QuadratureRule<ct,dim> value_type;

    //! make rules for all element types up to given order
    QuadratureRuleContainer (int pmax)
    {
      ////////////////////////
      // the cube rules
      ////////////////////////

      // allocate all rules up to requested order
      for (int p=1; p<=CubeQuadratureRule<ct,dim>::highest_order; p++)
      {
        if (p<=pmax)
        {
          QuadratureRule<ct,dim>* pointer = new CubeQuadratureRule<ct,dim>(p);
          rules.push_back(pointer);
        }
        else break;
      }

      // check if order can be achieved
      cube_maxorder = rules.back()->order();
      if (cube_maxorder<pmax)
        dverb << "Warning: Quadrature rule order " << pmax
              << " requested for cubes but only " << cube_maxorder
              << " available" << std::endl;
    }


    ~QuadratureRuleContainer()
    {
      typedef typename std::vector<QuadratureRule<ct,dim>*>::iterator Iterator;
      for(Iterator entry = rules.begin(); entry != rules.end(); ++entry)
        delete (*entry);
    }

    //! select the appropriate rule
    const QuadratureRule<ct,dim>& operator() (GeometryType type, int p)
    {
      if ( type.isLine() )
      {
        if (p>=1 && p<=cube_maxorder)
          return *(rules[p-1]);
      }

      DUNE_THROW(QuadratureOrderOutOfRange,
                 "QuadratureRule for order " << p << " and GeometryType "
                                             << type << " not available");
    }

    //! ConstIterator class for sequential access
    class const_iterator
    {
    public:
      //! construct from stl iterator
      const_iterator (const typename std::vector<QuadratureRule<ct,dim>*>::const_iterator& _i) : i(_i)
      {       }

      //! prefix increment
      const_iterator& operator++()
      {
        ++i;
        return *this;
      }

      //! prefix decrement
      const_iterator& operator--()
      {
        --i;
        return *this;
      }

      //! equality
      bool operator== (const const_iterator& it) const
      {
        return i==it.i;
      }

      //! inequality
      bool operator!= (const const_iterator& it) const
      {
        return i!=it.i;
      }

      //! dereferencing
      const QuadratureRule<ct,dim>& operator* () const
      {
        return **i;
      }

      //! arrow
      const QuadratureRule<ct,dim>* operator-> () const
      {
        return *i;
      }

    private:
      typename std::vector<QuadratureRule<ct,dim>*>::const_iterator i;
    };

    const_iterator begin ()
    {
      return const_iterator(rules.begin());
    }

    const_iterator end ()
    {
      return const_iterator(rules.end());
    }

  private:
    // the vector of all rules
    std::vector<QuadratureRule<ct,dim>*> rules;

    // mapping for cube rules
    int cube_maxorder;
  };


  /*-------------------------------------
     specialization for 3D-pyramids/prisms
     The general container and the singleton
     --------------------------------------*/

  //! A container for all quadrature rules
  template<typename ct>
  class QuadratureRuleContainer<ct,3>
  {
    enum { dim=3 };
  public:
    typedef QuadratureRule<ct,3> value_type;

    //! make rules for all element types up to given order
    QuadratureRuleContainer (int pmax)
    {
      // initialize index counter for rules in the array
      int index=0;
      int cubeindex=0;
      int simpindex=0;
      int prisindex=0;
      int pyrindex=0;

      ////////////////////////
      // the cube rules
      ////////////////////////

      // allocate all rules up to requested order
      // allocate all rules up to requested order
      for (int p=1; p<=CubeQuadratureRule<ct,dim>::highest_order; p++)
      {
        if (p<=pmax)
        {
          QuadratureRule<ct,dim>* pointer = new CubeQuadratureRule<ct,dim>(p);
          rules.push_back(pointer);
          cube_order_to_index[p] = index;
          index++;
          cubeindex=index;
        }
        else break;
      }

      ////////////
      // simplex rule
      /////////

      for (int m=1; m<=SimplexQuadraturePoints<dim>::MAXP; m++)
      {
        int p = SimplexQuadraturePointsSingleton<dim>::sqp.order(m);       // order of rule with m points
        if (p<=pmax)
        {
          QuadratureRule<ct,dim>* pointer = new SimplexQuadratureRule<ct,dim>(p);
          rules.push_back(pointer);
          if (m==1)
            for (int i=0; i<=SimplexQuadraturePoints<dim>::highest_order; i++)
              simplex_order_to_index[i] = index;
          else
            for (int i=0; i<=SimplexQuadraturePoints<dim>::highest_order; i++)
              if (rules[simplex_order_to_index[i]]->order()<i)
                simplex_order_to_index[i] = index;

          ++index;
          simpindex=index;
        }
        else break;
      }

      ////////////
      // prism rule
      /////////
      /*
         for (int m=1; m<=PrismQuadraturePoints<3>::MAXP; m++)
              {
                int p = PrismQuadraturePointsSingleton<3>::prqp.order(m); // order of rule with m points
                if (p<=pmax)
         {
          QuadratureRule<ct,dim>* pointer = new PrismQuadratureRule<ct,3>(p);
          rules.push_back(pointer);
          if (m==1)
            for (int i=0; i<=PrismQuadraturePoints<3>::highest_order; i++)
              prism_order_to_index[i] = index;
          else
            for (int i=0; i<=PrismQuadraturePoints<3>::highest_order; i++)
              if (rules[prism_order_to_index[i]]->order()<i)
                prism_order_to_index[i] = index;

         ++index;
          prisindex=index;
         }
                else break;
              }
       */
      for (int p=0; p<pmax; p++)
      {
        QuadratureRule<ct,dim>* pointer = new PrismQuadratureRule<ct,3>(p);
        rules.push_back(pointer);
        prism_order_to_index[p] = index;
        index++;
        prisindex=index;
      }
      ////////////
      // pyramid rule
      /////////

      for (int m=1; m<=PyramidQuadraturePoints<3>::MAXP; m++)
      {
        int p = PyramidQuadraturePointsSingleton<3>::pyqp.order(m);           // order of rule with m points
        if (p<=pmax)
        {
          QuadratureRule<ct,dim>* pointer = new PyramidQuadratureRule<ct,3>(p);
          rules.push_back(pointer);
          if (m==1)
            for (int i=0; i<=PyramidQuadraturePoints<3>::highest_order; i++)
              pyramid_order_to_index[i] = index;
          else
            for (int i=0; i<=PyramidQuadraturePoints<3>::highest_order; i++)
              if (rules[pyramid_order_to_index[i]]->order()<i)
                pyramid_order_to_index[i] = index;

          ++index;
          pyrindex=index;
        }
        else break;
      }


      // check if order can be achieved
      cube_maxorder = rules[cubeindex-1]->order();
      if (cube_maxorder<pmax)
        dverb << "Warning: Quadrature rule order " << pmax
              << " requested for cubes but only " << cube_maxorder << " available" << std::endl;

      simplex_maxorder = rules[simpindex-1]->order();
      if(simplex_maxorder<pmax)
        dverb << "Warning: Quadrature rule order " << pmax
              << " requested for simplex-" << (int)dim <<"D"<<" but only " << simplex_maxorder << " available" << std::endl;

      prism_maxorder = rules[prisindex-1]->order();
      if(prism_maxorder<pmax)
        dverb << "Warning: Quadrature rule order " << pmax
              << " requested for prism" <<" but only " << prism_maxorder << " available" << std::endl;
      pyramid_maxorder = rules[pyrindex-1]->order();

      if(pyramid_maxorder<pmax)
        dverb << "Warning: Quadrature rule order " << pmax
              << " requested for pyramid" <<" but only " << pyramid_maxorder << " available" << std::endl;
    }

    //! select the appropriate rule
    const QuadratureRule<ct,dim>& operator() (GeometryType type, int p)
    {
      if (type.isCube())
      {
        if (p>=1 && p<=cube_maxorder)
          return *(rules[cube_order_to_index[p]]);
      }
      if (type.isSimplex())
      {
        if(p>=1 && p<=simplex_maxorder)
          return *(rules[simplex_order_to_index[p]]);
      }
      if (type.isPrism())
      {
        if(p>=1 && p<=prism_maxorder)
          return *(rules[prism_order_to_index[p]]);
      }
      if(type.isPyramid())
      {
        if(p>=1 && p<=pyramid_maxorder)
          return *(rules[pyramid_order_to_index[p]]);
      }

      DUNE_THROW(QuadratureOrderOutOfRange,
                 "QuadratureRule for order " << p << " and GeometryType "
                                             << type << " not available");
    }

    ~QuadratureRuleContainer()
    {
      typedef typename std::vector<QuadratureRule<ct,dim>*>::iterator Iterator;
      for(Iterator entry = rules.begin(); entry != rules.end(); ++entry)
        delete (*entry);
    }
    //! ConstIterator class for sequential access
    class const_iterator
    {
    public:
      //! construct from stl iterator
      const_iterator (const typename std::vector<QuadratureRule<ct,dim>*>::const_iterator& _i) : i(_i)
      {       }

      //! prefix increment
      const_iterator& operator++()
      {
        ++i;
        return *this;
      }

      //! prefix decrement
      const_iterator& operator--()
      {
        --i;
        return *this;
      }

      //! equality
      bool operator== (const const_iterator& it) const
      {
        return i==it.i;
      }

      //! inequality
      bool operator!= (const const_iterator& it) const
      {
        return i!=it.i;
      }

      //! dereferencing
      const QuadratureRule<ct,dim>& operator* () const
      {
        return **i;
      }

      //! arrow
      const QuadratureRule<ct,dim>* operator-> () const
      {
        return *i;
      }

    private:
      typename std::vector<QuadratureRule<ct,dim>*>::const_iterator i;
    };

    const_iterator begin ()
    {
      return const_iterator(rules.begin());
    }

    const_iterator end ()
    {
      return const_iterator(rules.end());
    }

  private:
    // the vector of all rules
    std::vector<QuadratureRule<ct,dim>*> rules;

    // mapping for cube rules
    int cube_maxorder;
    int simplex_maxorder;
    int prism_maxorder;
    int pyramid_maxorder;

    int cube_order_to_index[CubeQuadratureRule<ct,dim>::highest_order+1];
    int simplex_order_to_index[SimplexQuadratureRule<ct,dim>::highest_order+1];
    int prism_order_to_index[PrismQuadratureRule<ct,3>::highest_order+1];
    int pyramid_order_to_index[PyramidQuadratureRule<ct,3>::highest_order+1];

  };

  // singleton holding a quadrature rule container
  template<typename ctype, int dim>
  struct QuadratureRules {
    static QuadratureRuleContainer<ctype,dim> rule;
  };

} // end namespace

#endif
