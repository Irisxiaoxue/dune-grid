// -*- tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
// vi: set et ts=4 sw=2 sts=2:
#ifndef DUNE_ALBERTA_DGFPARSER_HH
#define DUNE_ALBERTA_DGFPARSER_HH

#include <dune/grid/albertagrid.hh>
#include <dune/grid/albertagrid/gridfactory.hh>

#include <dune/grid/io/file/dgfparser/dgfparser.hh>
#include <dune/grid/io/file/dgfparser/dgfprojectionblock.hh>

#if HAVE_ALBERTA

namespace Dune
{

  template< int dim, int dimworld >
  struct DGFGridFactory< AlbertaGrid< dim, dimworld > >
  {
    typedef AlbertaGrid<dim,dimworld>  Grid;
    const static int dimension = Grid::dimension;
    typedef MPIHelper::MPICommunicator MPICommunicatorType;
    typedef typename Grid::template Codim<0>::Entity Element;
    typedef typename Grid::template Codim<dimension>::Entity Vertex;
    typedef Dune::GridFactory<Grid> GridFactory;

    explicit DGFGridFactory ( const std::string &filename,
                              MPICommunicatorType comm = MPIHelper::getCommunicator())
    {
      generate( filename );
    }

    Grid *grid () const
    {
      return grid_;
    }

    template< class Intersection >
    bool wasInserted ( const Intersection &intersection ) const
    {
      return factory_.wasInserted( intersection );
    }

    template< class Intersection >
    int boundaryId ( const Intersection &intersection ) const
    {
      return intersection.boundaryId();
    }

    template< int codim >
    int numParameters () const
    {
      if( codim == 0 )
        return dgf_.nofelparams;
      else if( codim == dimension )
        return dgf_.nofvtxparams;
      else
        return 0;
    }

    std::vector< double > &parameter ( const Element &element )
    {
      if( numParameters< 0 >() <= 0 )
      {
        DUNE_THROW( InvalidStateException,
                    "Calling DGFGridFactory::parameter is only allowed if there are parameters." );
      }
      return dgf_.elParams[ factory_.insertionIndex( element ) ];
    }

    std::vector< double > &parameter ( const Vertex &vertex )
    {
      if( numParameters< dimension >() <= 0 )
      {
        DUNE_THROW( InvalidStateException,
                    "Calling DGFGridFactory::parameter is only allowed if there are parameters." );
      }
      return dgf_.vtxParams[ factory_.insertionIndex( vertex ) ];
    }

  private:
    void generate( const std::string &filename );

    Grid *grid_;
    GridFactory factory_;
    DuneGridFormatParser dgf_;
  };


  template< int dim, int dimworld >
  inline void
  DGFGridFactory< AlbertaGrid< dim, dimworld > >::generate( const std::string &filename )
  {
    dgf_.element = DuneGridFormatParser::Simplex;
    dgf_.dimgrid = dim;
    dgf_.dimw = dimworld;

    std::ifstream file( filename.c_str() );
    if( !dgf_.readDuneGrid( file, dim, dimworld ) )
    {
      grid_ = new AlbertaGrid< dim, dimworld >( filename.c_str() );
      return;
    }

    if( dim == dimworld )
      dgf_.setOrientation( 0, 1 );
    dgf_.setRefinement( 0, 1, -1, -1 );

    dgf::GridParameterBlock parameter( file );
    std::string gridName = parameter.name( "AlbertaGrid" );

    for( int n = 0; n < dgf_.nofvtx; ++n )
    {
      typename GridFactory::WorldVector coord;
      for( int i = 0; i < dimworld; ++i )
        coord[ i ] = dgf_.vtx[ n ][ i ];
      factory_.insertVertex( coord );
    }

    GeometryType type( GeometryType::simplex, dimension );
    std::vector< unsigned int > elementId( dimension+1 );
    for( int n = 0; n < dgf_.nofelements; ++n )
    {
      // This is a nasty hack: The tetrahedrons generated by make6 are not
      // directly useable by ALBERTA. On every second tetrahedron we have to
      // switch the last 2 vertices (otherwise ALBERTA causes a segmentation
      // fault during refinement).
      if( (dimension == 3) && dgf_.cube2simplex && (n % 2 == 0) )
      {
        const int flip[ 4 ] = { 0, 1, 3, 2 };
        for( int i = 0; i <= dimension; ++i )
          elementId[ i ] = dgf_.elements[ n ][ flip[ i ] ];
      }
      else
      {
        for( int i = 0; i <= dimension; ++i )
          elementId[ i ] = dgf_.elements[ n ][ i ];
      }

      factory_.insertElement( type, elementId );

      // look for bounaries and insert them
      for( int face = 0; face <= dimension; ++face )
      {
        typedef typename DuneGridFormatParser::facemap_t::key_type Key;
        typedef typename DuneGridFormatParser::facemap_t::iterator Iterator;

        const Key key( elementId, dimension, face+1 );
        const Iterator it = dgf_.facemap.find( key );
        if( it != dgf_.facemap.end() )
          factory_.insertBoundary( n, face, it->second );
      }
    }

    if( GridFactory::supportPeriodicity )
    {
      typedef dgf::PeriodicFaceTransformationBlock::AffineTransformation Transformation;
      dgf::PeriodicFaceTransformationBlock block( file, dimworld );
      const int size = block.numTransformations();
      for( int k = 0; k < size; ++k )
      {
        const Transformation &trafo = block.transformation( k );

        typename GridFactory::WorldMatrix matrix;
        for( int i = 0; i < dimworld; ++i )
          for( int j = 0; j < dimworld; ++j )
            matrix[ i ][ j ] = trafo.matrix( i, j );

        typename GridFactory::WorldVector shift;
        for( int i = 0; i < dimworld; ++i )
          shift[ i ] = trafo.shift[ i ];

        factory_.insertFaceTransformation( matrix, shift );
      }
    }

    dgf::ProjectionBlock projectionBlock( file, dimworld );
    const DuneBoundaryProjection< dimworld > *projection
      = projectionBlock.template defaultProjection< dimworld >();
    if( projection != 0 )
      factory_.insertBoundaryProjection( *projection );
    const size_t numBoundaryProjections = projectionBlock.numBoundaryProjections();
    for( size_t i = 0; i < numBoundaryProjections; ++i )
    {
      GeometryType type( GeometryType::simplex, dim-1 );
      const std::vector< unsigned int > &vertices = projectionBlock.boundaryFace( i );
      const DuneBoundaryProjection< dimworld > *projection
        = projectionBlock.template boundaryProjection< dimworld >( i );
      factory_.insertBoundaryProjection( type, vertices, projection );
    }

    if( parameter.markLongestEdge() )
      factory_.markLongestEdge();

    const std::string &dumpFileName = parameter.dumpFileName();
    if( !dumpFileName.empty() )
      factory_.write( dumpFileName );

    grid_ = factory_.createGrid( gridName );
  }



  template< int dim, int dimworld >
  struct DGFGridInfo< AlbertaGrid< dim, dimworld > >
  {
    static int refineStepsForHalf ()
    {
      return dim;
    }

    static double refineWeight ()
    {
      return 0.5;
    }
  };

}

#endif // #if HAVE_ALBERTA

#endif // #ifndef DUNE_ALBERTA_DGFPARSER_HH
