// -*- tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
// vi: set et ts=4 sw=2 sts=2:
#ifndef DUNE_ALUGRID_MATRIXHELPER_HH
#define DUNE_ALUGRID_MATRIXHELPER_HH

#include <cmath>

#include <dune/common/exceptions.hh>
#include <dune/common/fmatrix.hh>
#include <dune/common/fvector.hh>

namespace Dune
{

  template< class K >
  struct ALUMatrixHelper
  {
    template< int m, int n >
    static void AAT ( const FieldMatrix< K, m, n > &A, FieldMatrix< K, m, m > &ret )
    {
      for( int i = 0; i < m; ++i )
      {
        for( int j = 0; j < m; ++j )
        {
          ret[ i ][ j ] = K( 0 );
          for( int k = 0; k < n; ++k )
            ret[ i ][ j ] += A[ i ][ k ] * A[ j ][ k ];
        }
      }
    }

    template< int m, int n, int p >
    static void ATB ( const FieldMatrix< K, m, n > &A, const FieldMatrix< K, m, p > &B, FieldMatrix< K, n, p > &ret )
    {
      for( int i = 0; i < n; ++i )
      {
        for( int j = 0; j < p; ++j )
        {
          ret[ i ][ j ] = K( 0 );
          for( int k = 0; k < m; ++k )
            ret[ i ][ j ] += A[ k ][ i ] * B[ k ][ j ];
        }
      }
    }

    template< int m, int n >
    static K sqrtDetAAT ( const FieldMatrix< K, m, n > &A )
    {
      _sqrtDetAAT( A );
    }

    template< int m, int n >
    static K rightInvA ( const FieldMatrix< K, m, n > &A, FieldMatrix< K, n, m > &ret )
    {
      _rightInvA( A, ret );
    }

    template< int m, int n >
    static void xTRightInvA ( const FieldMatrix< K, m, n > &A, const FieldVector< K, n > &x, FieldVector< K, m > &ret )
    {
      _xTRightInvA( A, x, ret );
    }

  private:
    static K _det ( const FieldMatrix< K, 0, 0 > &A ) { return K( 1 ); }
    static K _det ( const FieldMatrix< K, 1, 1 > &A ) { return A[ 0 ][ 0 ]; }

    static K _det ( const FieldMatrix< K, 2, 2 > &A )
    {
      return (A[ 0 ][ 0 ] * A[ 1 ][ 1 ] - A[ 0 ][ 1 ] * A[ 1 ][ 0 ]);
    }

    static K _det ( const FieldMatrix< K, 3, 3 > &A )
    {
      // code generated by maple
      const K t4  = A[ 0 ][ 0 ] * A[ 1 ][ 1 ];
      const K t6  = A[ 0 ][ 0 ] * A[ 1 ][ 2 ];
      const K t8  = A[ 0 ][ 1 ] * A[ 1 ][ 0 ];
      const K t10 = A[ 0 ][ 2 ] * A[ 1 ][ 0 ];
      const K t12 = A[ 0 ][ 1 ] * A[ 2 ][ 0 ];
      const K t14 = A[ 0 ][ 2 ] * A[ 2 ][ 0 ];

      return (t4*A[ 2 ][ 2 ] - t6*A[ 2 ][ 1 ] - t8 * A[ 2 ][ 2 ]
              + t10*A[ 2 ][ 1 ] + t12*A[ 1 ][ 2 ] - t14*A[ 1 ][ 1 ]);
    }

    template< int m, int n >
    static K _sqrtDetAAT( const FieldMatrix< K, m, n > &A )
    {
      FieldMatrix< K, n, m > invA;
      return _rightInvA( A, invA );
    }

    template< int m >
    static K _sqrtDetAAT ( const FieldMatrix< K, m, m > &A )
    {
      return std::abs( _det( A ) );
    }

    template< int m, int n >
    static K _rightInvA ( const FieldMatrix< K, m, n > &A, FieldMatrix< K, n, m > &ret )
    {
      FieldMatrix< K, m, m > aat, inv_aat;
      AAT( A, aat );
      K det2 = _rightInvA( aat, inv_aat );
      ATB( A, inv_aat, ret );
      return std::sqrt( det2 );
    }

    template< int m >
    static K _rightInvA ( const FieldMatrix< K, m, m > &A, FieldMatrix< K, m, m > &ret )
    {
      DUNE_THROW( NotImplemented, "ALUMatrixHelper: Inversion only implemented up to 3d." );
    }

    static K _rightInvA ( const FieldMatrix< K, 0, 0 > &A, FieldMatrix< K, 0, 0 > &ret )
    {
      return std::abs( _det( A ) );
    }

    static K _rightInvA ( const FieldMatrix< K, 1, 1 > &A, FieldMatrix< K, 1, 1 > &ret )
    {
      const K det = _det( A );
      ret[ 0 ][ 0 ] = K( 1 ) / det;
      return std::abs( det );
    }

    static K _rightInvA ( const FieldMatrix< K, 2, 2 > &A, FieldMatrix< K, 2, 2 > &ret )
    {
      const K det = _det( A );
      const K idet = K( 1 ) / det;
      ret[ 0 ][ 0 ] = A[ 1 ][ 1 ] * idet;
      ret[ 1 ][ 0 ] = -A[ 0 ][ 1 ] * idet;
      ret[ 0 ][ 1 ] = -A[ 1 ][ 0 ] * idet;
      ret[ 1 ][ 1 ] = A[ 0 ][ 0 ] * idet;
      return std::abs( det );
    }

    static K _rightInvA ( const FieldMatrix< K, 3, 3 > &A, FieldMatrix< K, 3, 3 > &ret )
    {
      const K det = _det( A );
      const K idet = K( 1 ) / det;
      ret[ 0 ][ 0 ] = (A[ 1 ][ 1 ] * A[ 2 ][ 2 ] - A[ 2 ][ 1 ] * A[ 1 ][ 2 ]) * idet;
      ret[ 1 ][ 0 ] = (A[ 2 ][ 0 ] * A[ 1 ][ 2 ] - A[ 1 ][ 0 ] * A[ 2 ][ 2 ]) * idet;
      ret[ 2 ][ 0 ] = (A[ 1 ][ 0 ] * A[ 2 ][ 1 ] - A[ 2 ][ 0 ] * A[ 1 ][ 1 ]) * idet;
      ret[ 0 ][ 1 ] = (A[ 2 ][ 1 ] * A[ 0 ][ 2 ] - A[ 0 ][ 1 ] * A[ 2 ][ 2 ]) * idet;
      ret[ 1 ][ 1 ] = (A[ 0 ][ 0 ] * A[ 2 ][ 2 ] - A[ 2 ][ 0 ] * A[ 0 ][ 2 ]) * idet;
      ret[ 2 ][ 1 ] = (A[ 2 ][ 0 ] * A[ 0 ][ 1 ] - A[ 0 ][ 0 ] * A[ 2 ][ 1 ]) * idet;
      ret[ 0 ][ 2 ] = (A[ 0 ][ 1 ] * A[ 1 ][ 2 ] - A[ 1 ][ 1 ] * A[ 0 ][ 2 ]) * idet;
      ret[ 1 ][ 2 ] = (A[ 1 ][ 0 ] * A[ 0 ][ 2 ] - A[ 0 ][ 0 ] * A[ 1 ][ 2 ]) * idet;
      ret[ 2 ][ 2 ] = (A[ 0 ][ 0 ] * A[ 1 ][ 1 ] - A[ 1 ][ 0 ] * A[ 0 ][ 1 ]) * idet;
      return std::abs( det );
    }

    template< int m, int n >
    static void _xTRightInvA ( const FieldMatrix< K, m, n > &A, const FieldVector< K, n > &x, FieldVector< K, m > &ret )
    {
      FieldVector< K, m > Ax;
      A.mv( x, Ax );
      FieldMatrix< K, m, m > aat;
      AAT( A, aat );
      _xTRightInvA( aat, Ax, ret );
    }

    template< int m >
    static void _xTRightInvA ( const FieldMatrix< K, m, m > &A, const FieldVector< K, m > &x, FieldVector< K, m > &ret )
    {
      DUNE_THROW( NotImplemented, "ALUMatrixHelper: Inversion only implemented up to 3d." );
    }

    static void _xTRightInvA ( const FieldMatrix< K, 0, 0 > &A, const FieldVector< K, 0 > &x, FieldVector< K, 0 > &ret ) {}

    static void _xTRightInvA ( const FieldMatrix< K, 1, 1 > &A, const FieldVector< K, 1 > &x, FieldVector< K, 1 > &ret )
    {
      ret[ 0 ] = x[ 0 ] / _det( A );
    }

    static void _xTRightInvA ( const FieldMatrix< K, 2, 2 > &A, const FieldVector< K, 2 > &x, FieldVector< K, 2 > &ret )
    {
      const K det = _det( A );
      const K idet = K( 1 ) / det;
      ret[ 0 ] = (A[ 1 ][ 1 ] * x[ 0 ] - A[ 1 ][ 0 ] * x[ 1 ]) * idet;
      ret[ 1 ] = (A[ 0 ][ 1 ] * x[ 0 ] - A[ 0 ][ 0 ] * x[ 1 ]) * idet;
    }

    static void _xTRightInvA ( const FieldMatrix< K, 3, 3 > &A, const FieldVector< K, 3 > &x, FieldVector< K, 3 > &ret )
    {
      const K det = _det( A );
      const K idet = K( 1 ) / det;

      const K t0 = A[ 2 ][ 0 ] * x[ 0 ];
      const K t1 = A[ 2 ][ 1 ] * x[ 0 ];
      const K t2 = A[ 2 ][ 2 ] * x[ 0 ];

      const K t3 = A[ 2 ][ 0 ] * x[ 1 ];
      const K t4 = A[ 2 ][ 1 ] * x[ 1 ];
      const K t5 = A[ 2 ][ 2 ] * x[ 1 ];

      const K t6 = A[ 0 ][ 0 ] * x[ 2 ];
      const K t7 = A[ 0 ][ 1 ] * x[ 2 ];
      const K t8 = A[ 0 ][ 2 ] * x[ 2 ];

      ret[ 0 ] = (t2 * A[ 1 ][ 1 ] - t1 * A[ 1 ][ 2 ] + t4 * A[ 0 ][ 2 ] - t5 * A[ 0 ][ 1 ] + t7 * A[ 1 ][ 2 ] - t8 * A[ 1 ][ 1 ]) * idet;
      ret[ 1 ] = (t0 * A[ 1 ][ 2 ] - t2 * A[ 1 ][ 0 ] + t5 * A[ 0 ][ 0 ] - t3 * A[ 0 ][ 2 ] + t8 * A[ 1 ][ 0 ] - t6 * A[ 1 ][ 2 ]) * idet;
      ret[ 2 ] = (t1 * A[ 1 ][ 0 ] - t0 * A[ 1 ][ 1 ] + t3 * A[ 0 ][ 1 ] - t4 * A[ 0 ][ 0 ] + t6 * A[ 0 ][ 0 ] - t7 * A[ 1 ][ 0 ]) * idet;
    }
  };

} // namespace Dune

#endif // #ifndef DUNE_ALUGRID_MATRIXHELPER_HH
